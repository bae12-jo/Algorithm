
# 개요
큰 문제를 작은 문제로 나누어 풀어가는 방법은 크게 2가지가 있다
> DynamicProgramming (다이나믹프로그래밍)
    * 작은 문제에서 중복이 발생할 수 있다
> Divide&Conguer (분할정복)
    * 작은 문제에서 중복이 발생하지 않는다


## Dynamic Programming 속성
* 아래의 두 가지 속성을 만족해야 다이나믹 프로그래밍으로 문제를 풀 수 있다

### (1) Overlapping Subproblem
* 피보나치 수
    * F0=0
    * F1=1
    * Fn=Fn-1+Fn-2(n>=2)
    * 큰=작+작
    * 큰 문제: N 번째 피보나치 수를 구하는 문제
    * 작은 문제: N-1 번째 피보나치 수를 구하는 문제, N-2번째 피보나치를 구하는 문제
```c++
int fibonacci(int n){ // 복잡도(2^n)
    if (n<=1){
        return n; // 0과 1은 예외
    }else{
        return fibonacci(n-1) + fibonacci(n-2);
    }
}
```
* 주로 재귀를 사용

### (2) Optimal Substrance
* 문제의 정답을 작은 문제의 정답에서 구할 수 있다
    * 예
    * 서울에서 부산을 가는 가장 빠른 길이 대전과 대구를 순서대로 거쳐야 한다면
    * 대전에서 부산을 가는 가장 빠른 길은 대구를 거쳐야 한다
    * [서울, 대전, 대구, 부산]
* 문제의 크기에 상관없이 어떤 한 문제의 정답은 일정하다


* 다이나믹 프로그래밍에서 각 문제는 한 번만 풀어야 한다
* optimal substructure를 만족하기 때문에 같은 문제는 구할 때마다 정답이 같다
* 따라서 정답을 한 번 구했으면 정답을 어딘가에 메모해놓는다
* 이런 메모하는 것을 코드의 구현에서는 배열에 저장하는 것으로 할 수 있다
* 메모를 한다고 해서 영어로 memoization이라고 한다
```c++
int memp[100]; // 모든 문제를 한 번씩만 풀기 때문에 O(n+1)
// 문제의 개수 n, 함수의 복잡도 1 (더하기 연산)
int fibonacci(int n){
    if (n<=1){
        return n; // 0과 1은 예외
    }else{
        if(memo[n]>0){
            return memo[n];
        }
        memo[n] = fibonacci(n-1) + fibonacci(n-2);
        return memo[n]; // memo[i]=0 이라면 답을 구하지 않은 것
    }
}
```

## Dynamic Programming 구현 방법
* 두 구현 방법 중 어떤 것을 사용하던지 상관 없다
* 두 구현 방법의 시간 차이는 정확히 알 수 없다
* 재귀를 사용하면 스택오버플로우가 발생할 수 있다
* 스택오버플로우가 발생했다면 보통 점화식을 잘못 세운 것이다
* 파이썬의 경우 스택오버플로우가 잘 나지만 c++, java는 잘 나지 않는다
* 반복이 더 빠를 것 같지만, 반복은 실제로 모든 케이스를 풀게 된다
* 재귀는 원하는 것만 풀게 되므로 경우에 따라 빠를 수 있다
* Top-down과 Bottom-up 중 하나로만 풀리는 문제도 있으므로 둘 다 연습해야 한다

### (1) Top-down
* 재귀를 사용하는 것
* 문제를 풀어야 한다
    * fibonacci(n)
* 큰 문제를 작은 문제로 나눈다
    * fibonacci(n-1)과 fibonacci(n-2)로 문제를 나눈다
* 작은 문제를 푼다
    * fibonacci(n-1)과 fibonacci(n-2)를 호출해 문제를 푼다
* 작은 문제를 풀었으니, 이제 큰 문제를 푼다
    * fibonacci(n-1)과 fibonacci(n-2)의 값을 더해 문제를 푼다

### (2) Bottom-up
* 반복문을 사용하는 것
```c++
    int d[100];
    int fibonacci(int n){
        // 가장 작은 문제 0과 1 풀기
        d[0]=0;
        d[1]=1;
        // 2부터 키워나가면서 풀어나가기
        for(int i=2; i<=n; i++){
            d[i] = d[i-1]+d[i-2];
        }
        return d[n];
    }
```
* 문제를 크기가 작은 문제부터 차례대로 푼다
    * for(int i=2; i<=n; i++)
* 문제의 크기를 조금씩 크게 만들면서 문제를 점점 푼다
    * for(int i=2; i<=n; i++)
* 작은 문제를 풀면서 왔기 때문에, 큰 문제는 항상 풀 수 있다
    * d[i] = d[i-1]+d[i-2];
* 반복하다 보면 가장 큰 문제를 풀 수 있다
    * d[n]


## 점화식
* 문제에서 구하려고 하는 답을 문장으로 나타낸다
* 복잡도
    > 함수의 호출 횟수 * 함수의 시간 복잡도
    > 문제의 개수 * 문제 1개 푸는데 필요한 시간 복잡도
