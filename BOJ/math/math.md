# (1) 모듈러 연산

* (A+B) mod M = ((A mod M) + (B mod M)) mod M
* (AXB) mod M = ((A mod M) X (B mod M)) mod M
* (A-B) mod M = ((A mod M) - (B mod M)+M) mod M
    * 빼기 연산의 경우 언어에 따라 음수값이 나올 수 있기 때문


--------------------------



# (2) 최대 공약수 (GCD)
## 유클리드 호제법 사용하기
* GCD(a, b)
* a%b=r, GCD(b, r)
* 이때 r=0이 되는 b가 최대 공약수
    *  GCD(24, 16) -> GCD(16, 8) -> GCD(8, 0)

### 재귀함수를 사용하여
``` c++
int gcd(int a, int b){
    if (b==0) return a;
    else return gcd(b, a%b);
}
```

### 반복문을 사용하여
```c++
int gcd(int a, int b){ // O(logn)
    while (b!=0){
        int r = a%b;
        a = b;
        b = r;
    }
    return a;
}
```

* 최대공약수가 1인 두 수는 서로소(Coprime)


# (3) 최소 공배수 (LCM)
* G = GCD(A, B)
* AXB = GCD*LCM
* LCM=(A*B)/G


------------------------------------------------


# (4) 소수
* 약수가 1과 자기 자신 밖에 없는 수
* 2, 3, 4, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47...
## (4-1) 어떤 n이 소수인지 아닌지 판별하는 방법
### - 기본 풀이
```c++
bool prime(int n){ // O(N)
    if (n<2){
        return false;
    }
    for (int i=2; i<=n-1; i++){
        if (n%i==0){
            return false;
        }
    }
    return true;
}
```


### - 다른 풀이
* n이 소수가 되려면 2보다 크거나 같고, n/2보다 작거나 같은 자연수로 나누어 떨어지면 안된다
* n = a*b = 2*n/2 (a가 작을수록 b는 크다, a<b)
* 가능한 a 중 가장 작은 값은 2이므로 b는 n/2를 넘지 않는다
* n의 약수 중에서 가장 큰 것은 n/2보다 작거나 같기 때문
* n/2+1 ~ n-1 사이에는 절대 약수가 있을 수 없음
```c++
bool prime(int n){ // O(n/2) = O(n)
    if (n<2){
        return false;
    }
    for (int i=2; i<=n/2; i++){
        if (n%i == 0){
            return false;
        }
    }
    return true; 
}
```

### - 좀 더 효율적인 풀이 (복잡도 root(n))
* n=a*b (a<=b) 일 때, a<=root(n), b>=root(n)
* a<root(n), b<root(n) 이면 a*b<n (성립불가)
* a>root(n), b>root(n) 이면 a*b>n (성립불가)
* a, b 모두에 약수가 없어야 하는데 root(n)보다 작은 쪽이 경우의 수가 적음
* 즉 n이 소수가 되려면 2보다 크거나 같고, 루트 n보다 작거나 같은 자연수로 나누어 떨어지면 안된다
* 두 수 a와 b의 차이가 가장 작은 경우는 루트 n이다
* 따라서 루트 n까지만 검사를 해보면 된다
```c++
bool prime(int n){
    if (n<2){
        return false;
    }
    for (int i=2; i*i<=n; i++){ // 실수는 근사값이므로 사용 지양, 정수로 처리하기 위해 i*i 사용
        if (n%i == 0){
            return false;
        }
    }
    return true; 
}
```

## (4-2) n 보다 작거나 같은 모든 자연수 중에서 소수를 찾아내는 방법
* O(n*root(n)) 은 범위의 소수를 구할 때는 느린 방법
### - 에라토스테네스의 체 
* 프라임하모닉 시리즈는 nloglogn, 소수를 구할 때 가장 빠른 알고리즘
``` c++
int prime[100]; // 소수 저장
int pn=0; // 소수의 개수
bool check[101]; // 지워지면 true
int n = 100;
for (int i=2; i<=n; i++){
    if (check[i]==false){ // 지워지지 않은 가장 작은 수
        prime[pn++] = i; // 소수 카운트
        for (int j=i*i; j<=n; j+=i){ // 배수를 지우기
        // i*i보다는 i+i 혹은 i*2를 쓰는 것이 바람직
        // n이 1백만 이상일 경우 overflow 발생
            check[j] = true;
        }
    }
}
```


# (5) 골드바흐의 추측
* 2보다 큰 모든 짝수는 두 소수의 합으로 표현 가능
* (골드바흐의 약한 추측) 5보다 큰 모든 홀수는 세 소수의 합으로 표현 가능하다
* 아직 증명되지 않은 문제지만, 10^18 이하에서는 참인 것이 증명되어 있다
* N=A+B 일 때, N-B가 소수임을 확인하기 위해서 check[N-B]==false

* 에라토스테네스의 체를 사용할 경우
* 어떤 수 N이 소수인지 아닌지 판별하기 위해 루트 n 방법을 사용할 필요가 없다
* 에라토스테네스의 결과에서 지워지지 않으면 소수, 지워지면 소수가 아니기 때문이다

#### - 좀 더 빠른 방법
* 모든 소수는 6n+1, 6n+5 꼴로 나타낼 수 있다
* 에라토스테네스의 체를 6의 배수 단위로 건너뛰어 더 빠르게 구현 가능
* 그러나 에라토스테네스의 체도 충분히 빠르기 때문에 효과가 극적이지는 않음


-----------------------------


# (6) 팩토리얼
* 매우 큰 값으로 브루트포스 할 때 중요한 의미를 가짐
* N! = 1*2*...*N
    * 6!=720
    * 8!=40320
    * 10!=3628800
    * 20! // int형 범위를 넘어감

------------------------------------

# (7) 진법 변환
* 진법 변환은 알고리즘에서 거의 중요하지 않음
#### 2진수 -> 8진수 변환
* 2진수의 3자리가 8진수 1개에 해당
#### 8진수 -> 2진수 변환
* 8진수 1개가 2진수의 3자리에 해당